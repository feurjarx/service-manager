# Система управления сервисами

# Требования к системе:
1 ОС: Windows, Unix (Mac ?)

2 Наличие установленого docker. 

- Для ОС Windows достаточно с оф. сайта скачать msi и установить. 
- Для Unix систем выполнить:
```
./service.sh host docker install
```

3 Создать .env конфигурационный файл по образцу .env.example с необходимым окружением
 
# Структура системы
- services \
    - docker \
        - service1 \
            - operation1.sh
            - operation2.sh
            - ...
            - operationN.sh
        - service2 \ 
        - ... 
        - serviceN \ 
    - host \
        - service1 \
        - service2 \ 
        - ... 
        - serviceN \
- service.sh
- docker-compose.dev.yml
- docker-compose.prod.yml
- .env

В корне имеется главный скрипт service.sh (entrypoint).
Все операции с сервисами выполняются только через данный скрипт, потому что именно он подгружает переменное окружение с файла .env.  
Данный скрипт иммет следующий синтаксис: 
```
service.sh <service-type> <service-name> <service-action>
``` 
##service-type
В данной системе сервисы деляться на два типа: docker и host.

1 docker. 
Сервисы, запускаемые из под docker как контейнеры.

2 host. 
Сервисы, запускаемые локально. Здесь находятся скрипты, которые могут переиспользоваться Dockerfile'ами.
Данные скрипты планируется запускать непосредственно на удаленном хосте (например, через Ansible).

##service-name
Название сервиса, над которым предполагается совершить операцию. 
Название сервиса определяется по названию подкаталога в каталоге типа сервиса. 
Например, ./services/docker/web или services/host/sshd. 

##service-action
Определяет необходимое действие (операция) над сервисом.
Операция по типу могут быть двух уровней:
- нижнего (определяют действия для конкретного одного сервиса, находиться в каталоге сервиса)
- верхнего (определяют универсальные действия, находиться в каталоге типа сервиса)

Основные операции:
- deploy (установка build + run),
- build (сборка образа (image) по Dockerfile в каталоге сервиса) 
- run (запуск instance с образа, т.е. контейнера)
- start (запуск, возобновление контейнера)
- stop (остановка контейнера)
- remove (удаление контейнера)
- kill (stop + remove)
- destroy (kill + уничтожение ранее собранных образов для этого сервиса по Dockerfile)
- up (запуск контейнеров по docker-compose.dev.yml или docker-compose.prod.yml в зависимости от параметра DEV_MODE в .env)
- down (стоп контейнеров, поднятых через up)
- logs (смотреть логи с контейнера)
- и др.

Данные базовые операции одноименны с командами docker (см. оф. документацию)

Если требуется собрать свой образ, то создается файл build, в котором запускаем процесс сборки своего образа.
Если есть build, значит, как правило, должен быть destroy, в котором описан, как минимум, процесс остановки контейнера и уничтожения его образа.
Если требуется использовать образ с репозитоия docker, то достаточно создать два файла: run и kill, потому что своих образов не будет 

При необходимости можно расширять список действий. 
Для этого нужно в каталоге конкретного сервиса создать скрипт, описывающий поведение над сервисом.
При этом название скрипта(.sh) будет определять название операции. 
Если же создать скрипт уровнем выше (в каталоге host или docker), 
то такой скрипт будет универсален и будет выполняться в случае отсутствия файла операции в конкретном сервисе.
Например, можно выполнить следующую команду:
```
./service.sh docker pma stop
```
Команда успешно остановит контейнер phpMyAdmin, несмотря на то, что в каталоге ./services/docker/pma нет скрипта stop.sh. 

Стоит отметить, что если вдруг потребуется переопределить операцию stop для phpMyAdmin сервиса, то достаточно будет создать скрипт ./services/docker/pma/stop.sh.
В таком случае скрипт верхнего уровня (./services/docker/stop.sh) не выполяется.
Рекомендуется придумывать лаконичные, очевидные и короткие названия, чтобы удобнее было работать потом из консоли.


